[{"categories":["Java"],"content":"为什么使用单元测试 一般来说，验证的两个思路是证明和证伪，分别对应着软件验证的形式化验证和测试。 证明适用于在有明确的逻辑范畴内通过演绎推理（如三段论、假言推理等）进行；证伪可通过举出反例的方式进行。 软件领域的性质导致证明的困难及收效甚微，绝大部分都采用测试来验证。 根据测试目的的不同有功能测试、性能测试等；根据是否了解测试对象分为黑盒测试与白盒测试，单元测试属于白盒测试。 一般来说，开发人员了解代码的结构，自己走一遍流程或CodeReview等形式基本可以发现bug，但为了团队中其他人员及日后的维护，单元测试有一定的存在的合理性。 因此需要保持单元测试中方法的独立性，隔离测试依赖，调用其他方法时需要模拟；给定输入，执行测试，验证输出，需要用到断言。 JAVA常用测试框架junit、mockito、powermock junit常用注解 @Ignore 该注解标记的测试方法在测试中会被忽略 @Test(expected=xxxException.class) 断言该方法会抛出异常 @Test(timeout=1000) 执行时间超过设置的值该案例会失败 @RunWith(JUnit4.class) 默认运行器 @RunWith(PowerMockRunner.class) PowerMockRunner运行器 @RunWith(Parameterized.class) 参数化运行器 @Rule public class ExpectedExceptionsTest { @Rule public ExpectedException thrown = ExpectedException.none(); @Test public void verifiesTypeAndMessage() { thrown.expect(RuntimeException.class); thrown.expectMessage(\"Runtime exception occurred\"); throw new RuntimeException(\"Runtime exception occurred\"); } } 参数化测试 @RunWith(Parameterized.class) public class Testa { @Parameterized.Parameters public static Collection\u003c?\u003e data() { return Arrays.asList(new Object[][] { { \"1+2\", 3 }, { \"1+2+5\", 8 }}); } @InjectMocks Calculator calc; @Parameterized.Parameter(0) public String input; @Parameterized.Parameter(1) public int expected; @Test public void testCalculate() { int r = calc.calculate(this.input); assertEquals(this.expected, r); } } 断言 assertEquals(a, b) 测试a是否等于b（a和b是原始类型数值或者必须为实现比较而具有equal方法） assertFalse(a) 测试a是否为false（假），a是一个Boolean数值。 assertTrue(a) 测试a是否为true（真），a是一个Boolean数值 assertNotNull(a) 测试a是否非空，a是一个对象或者null。 assertNull(a) 测试a是否为null，a是一个对象或者null。 assertNotSame(a, b) 测试a和b是否没有都引用同一个对象。 assertSame(a, b) 测试a和b是否都引用同一个对象。 fail(string) Fail让测试失败，并给出指定信息。 mockito使用介绍 通过代码创建 public class UserServiceTest { private UserService userService; private UserDao mockUserDao; @Before public void setUp() { mockUserDao = mock(UserDao.class); userService = new UserServiceImpl(); userService.setUserDao(mockUserDao); } 通过注解创建 public class UserServiceTest { @InjectMocks private UserServiceImpl userService; @Mock private UserDao mockUserDao; } 常用方法 verify verify(mock, never()).add(); 验证add方法没有被调用 verify(mock, times(2)).add(); 验证add方法被调用了2次 verify(mock, atLeast(n)).someMethod(); 方法至少被调用n次 verify(mock, atMost(n)).someMethod(); 方法最多被调用n次 when when(mock.someMethod()).thenReturn(value1).thenReturn(value2); when(mock.someMethod()).thenThrow(new RuntimeException()); spy List spy = spy(new LinkedList()); when(spy.get(0)).thenReturn(“foo\"); doReturn(\"foo\").when(spy).get(0); 使用powermock 测试private方法 @RunWith(PowerMockRunner.class) //类上加注解 @PrepareForTest({xxx.class}) @PrepareForTest({RpaRightsConfService.class}) public class RpaRightsConfServiceTest { @InjectMocks private RpaRightsConfService rpaRightsConfService; @Test public void getCellValue() throws Exception{ Row row = Mockito.mock(Row.class); Cell cell = Mockito.mock(Cell.class); cell.setCellType(Cell.CELL_TYPE_STRING); Mockito.when(row.getCell(Mockito.anyInt())).thenReturn(cell); //通过反射 Method method1 = rpaRightsConfService.getClass().getDeclaredMethod(\"getCellValue\", Row.class,int.class); method1.setAccessible(true);// 抑制访问修饰符，使得私有方法变为可以访问的 method1.invoke(rpaRightsConfService,row,3); Mockito.verify(row, Mockito.times(1)).getCell(Mockito.anyInt()); //或者通过PowerMockito.method Method method2 = PowerMockito.method(RpaRightsConfService.class, \"getCellValue\", Row.class,int.class); Object x2 = method2.invoke(rpaRightsConfService,row,3); assertEquals(Integer.parseInt(x2.toString()),0); } } 使用powermock mock静态方法/final方法/new @RunWith(PowerMockRunner.class) //类上加注解 @PrepareForTest({xxx.class}) @PrepareForTest({JSON.class,HSSFWorkbook.class}) public class RpaRightsConfServiceTest { @InjectMocks private RpaRightsConfService rpaRightsConfService; @Test public void save() { //mock 静态 PowerMockito.mockStatic(JSON.class); List\u003cRpaRightsConfVo\u003e rpaRightsConfVoList =new ArrayList\u003cRpaRightsConfVo\u003e(); rpaRightsConfVoList.add(new RpaRightsConfVo()); PowerMockito.when(JSON.parseArray(formListJson, RpaRightsConfVo.class)).thenReturn(rpa","date":"2021-06-20","objectID":"/%E5%85%B3%E4%BA%8E%E8%BD%AF%E4%BB%B6%E9%AA%8C%E8%AF%81%E4%B8%AD%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/:0:0","tags":["Java","测试"],"title":"关于软件验证中的单元测试","uri":"/%E5%85%B3%E4%BA%8E%E8%BD%AF%E4%BB%B6%E9%AA%8C%E8%AF%81%E4%B8%AD%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"categories":null,"content":"关于作者 z世代 热衷于修仙（字面意思） 对能让自己沉浸其中或置身其外的东西感兴趣，比如音乐、拳击、钓鱼等 吃饭的工作是后端工程师 对机器学习也有些兴趣，奈何数学太渣，能做个碉堡侠就满足了 最近在研究区块链，是个挺好儿的东西，我话讲完，谁赞成，谁反对 就介绍这么多，其他的有缘再说 大佬博客 阮一峰 王垠 physixfan 友情链接(欢迎留言加友链) 赞助个鸡腿 推荐数字货币支付： BTC BCH ETH LTC USDT DOGE ","date":"2021-06-12","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"}]